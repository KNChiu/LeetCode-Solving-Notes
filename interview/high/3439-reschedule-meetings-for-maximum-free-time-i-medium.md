---
description: Greedy Array, Sliding Window
---

# 3439 - Reschedule Meetings for Maximum Free Time I - Medium

## 釐清需求與邊界條件

* 輸入：給定兩個陣列 `startTime` 與 `endTime`，分別代表 n 場不重疊的會議之開始與結束時間。
* 輸出：最大化事件期間內最大的連續空閒時間，找到一段最長的連續不被會議佔用的時間。
* 限制條件：
  * 事件從時間 t = 0 至 t = eventTime。
  * 可以重排最多 k 場會議的開始時間
  * 會議的持續時間不變。
  * 會議的相對順序不變，且調整後依然保持不重疊。
  * 調整後的會議時間必須完全落在 \[0, eventTime] 區間內。
  * 若 `k = 0`，表示不能調整任何會議，答案即為原始排程中的最大空閒區間。
  * 若 `n = 0`（沒有會議），則最大空閒時間就是 `eventTime`。
  * 特別需注意事件開始前（t = 0 到第一個會議）以及事件結束後（最後一個會議到 eventTime）的空閒區間。

## 口述解法

* **(1) 內部函數：`get(i)`**
  * **功能**：計算原始排程中各個間隔的空閒時間，具體定義如下：
    * **當 i == 0**：表示事件開始到第一場會議開始的間隔，返回 `startTime[0]`。
    * **當 i == n**：表示最後一場會議結束到事件結束的間隔，返回 `eventTime - endTime[-1]`。
    * **其他情況**：表示相鄰兩場會議之間的空閒時間，返回 `startTime[i] - endTime[i-1]`。
* **(2) 主要函數：`maxFreeTime`**
  * **步驟說明：**
    1. **初始化**：
       * 取得會議數量 `n`。
       * 定義 `ans`（用於記錄最大空閒時間）以及 `s`（用於累積目前合併後的空閒時間）。
    2. **滑動窗口遍歷：**
       * 利用一個從 0 到 n 的迴圈，每一個 `i` 代表一個空閒區間：
         * **累加當前空閒區間**：透過呼叫 `get(i)`，將該區間的空閒時間加入 `s`。
         * 當 `i < k` 時，表示累積的空閒區間還不足以合併 k 個調整（因為調整 k 場會議會合併 k+1 個空閒區間），因此不計算答案。
         * 當 `i >= k` 時：
           * 更新 `ans` 為 `max(ans, s)`，紀錄當前窗口內的最大空閒時間。
           * 為了保持窗口大小固定，從 `s` 中扣除最左側的空閒區間，也就是 `get(i - k)`。
    3. **返回答案**：
       * 遍歷結束後，返回 `ans` 即為經過最多 k 次調整後的最大連續空閒時間。
* **核心思想**：
  * 調整會議其實就是將原本分散的空閒區間合併起來。透過滑動窗口，將連續的 k+1 個原始空閒區間合併，並不斷移動窗口來找到最大值。

## 測試與優化

* 程式碼

```python
class Solution:
    def maxFreeTime(self, eventTime: int, k: int, startTime: List[int], endTime: List[int]) -> int:
        def get(i: int) -> int:
            if i == 0:
                return startTime[0]
            elif i == n:
                return eventTime - endTime[-1]
            else:
                return startTime[i] - endTime[i-1]

        n = len(startTime)
        ans = s = 0

        for i in range(n+1):
            s += get(i)
            if i < k:
                continue
            ans = max(ans, s)
            s -= get(i - k)
        return ans
```

* 測資與注意事項
  * **為什麼需要 k+1 個空閒區間？**\
    當你調整 k 場會議時，這 k 場會議之間會產生 k+1 個空閒區間（包含事件開始前的空閒與結束後的空閒）。這些連續的空閒區間合併起來才能算作一次完整的調整結果。
  * **if i < k: continue 的意義**\
    在迴圈中，每一次迭代我們都累積一個空閒區間（透過 `s += get(i)`）。
    * 當 i 小於 k 時，累積的空閒區間數量還不夠 k+1 個，無法構成一個完整的「調整後合併」的狀態，因此不應該立即更新答案或是進行窗口的滑動。
    * `continue` 的作用是跳過當前迴圈剩餘部分，等到累積的空閒區間數達到 k+1 個（也就是 i >= k）時，才開始計算合併後的最大空閒時間，並從累積值中扣除最舊的空閒區間（也就是進行窗口的滑動）。

## 時間與空間複雜度

* 時間複雜度：**O(n)**
  * 主迴圈遍歷 n+1 次，每次操作皆為 O(1) 的計算，因此總時間複雜度為 O(n)。
* 空間複雜度：**O(1)**
  * 僅使用常數數量的變數（如 `ans`, `s`, `n`），不需要額外的數據結構來存儲中間結果。
