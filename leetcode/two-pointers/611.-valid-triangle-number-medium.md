---
description: Greedy, Array, Two Pointers, Binary Search, Sorting
---

# 611. Valid Triangle Number - Medium

## 釐清需求與邊界條件

* #### 輸入
  * `nums`: 整數陣列，代表各個邊的長度
  * 陣列長度範圍：1 ≤ nums.length ≤ 1000
  * 元素值範圍：0 ≤ nums\[i] ≤ 1000
* #### 輸出
  * 整數，表示可以組成三角形的三元組數量
* #### 邊界條件
  * **三角形不等式**：對於三邊 a, b, c，必須滿足 a + b > c, a + c > b, b + c > a
  * **最關鍵觀察**：當 a ≤ b ≤ c 時，只需檢查 a + b > c（因為其他兩個條件自動滿足）
  * 陣列長度小於 3 時，回傳 0
  * 包含 0 的邊無法組成三角形

## 口述解法

* #### 內部函數說明
  * **bisect\_left(nums, target, lo=start)**：
    * 在 nums\[start:] 中找到第一個 ≥ target 的位置
    * 返回位置減 1 即為最大有效第三邊的索引
  * **計數邏輯**：`ans += k - j`
    * k 是最大有效第三邊索引
    * j 是當前第二邊索引
    * 區間 \[j+1, k] 內的所有元素都可作為第三邊
* #### 步驟說明
  1. 排序後，對每組 (i, j)，第三邊 k 必須滿足：
     * `j < k < n`（位置約束）
     * `nums[k] < nums[i] + nums[j]`（三角形不等式）
  2. 二分搜尋找到 `nums[k] < nums[i] + nums[j]` 的最大 k
  3. 累加符合條件的 k 的個數

## 測試與優化

* 程式碼

```python
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans, n = 0, len(nums)
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                k = bisect_left(nums, nums[i] + nums[j], lo=j + 1) - 1
                ans += k - j
        return ans
```

## 時間與空間複雜度

* 時間複雜度：**O(n² log n)**
  * **排序**：O(n log n)
  * **雙重迴圈**：O(n²)
  * **每次二分搜尋**：O(log n)
  * **總體**：O(n log n) + O(n² × log n) = **O(n² log n)**
* 空間複雜度：O(1)
