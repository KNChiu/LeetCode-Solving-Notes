---
description: String, Binary Search, Prefix Sum, Sliding Window
---

# 2024.Maximize the Confusion of an Exam - Medium

## 釐清需求與邊界條件

* **輸入:**
  * `answerKey`: 字符串，只包含 'T' 和 'F'，代表考試答案
  * `k`: 整數，最多可以改變的答案數量
* **輸出:**
  * 整數，返回可以獲得的最大連續相同答案長度
* **邊界條件:**
  * `1 ≤ answerKey.length ≤ 5 * 10^4`
  * `answerKey[i]` 只能是 'T' 或 'F'
  * `0 ≤ k ≤ answerKey.length`
  * 特殊情況：k=0 時只能找現有的最長連續序列；k≥字符串長度時可以將整個字符串變成相同字符

## 口述解法

*   #### 主要函數 `maxConsecutiveAnswers`:

    核心思想是使用滑動窗口（Sliding Window）。要獲得最長連續相同答案我們可以：

    1. 嘗試將所有答案都變成 'T'（最多改變 k 個 'F'）
    2. 嘗試將所有答案都變成 'F'（最多改變 k 個 'T'）
    3. 取兩種情況的最大值
*   #### 內部函數 `check(c: str)`:

    使用滑動窗口找出最多改變 k 個非 c 字符後，能得到的最長連續 c 字符序列：

    **步驟說明：**

    1. 初始化左指針 `l=0`，計數器 `cnt=0`，窗口大小 `windowSize=0`，答案 `ans=0`
    2. 右指針 `r` 遍歷整個字符串：
       * 擴大窗口：`windowSize += 1`
       * 如果當前字符不是目標字符 c：`cnt += 1`（需要改變的字符數+1）
       * **收縮窗口**：當需要改變的字符數 > k 時：
         * 移動左指針，如果左指針指向的字符不是 c，則 `cnt -= 1`
         * 縮小窗口大小
       * 更新最大窗口大小
    3. 返回最大窗口大小

## 測試與優化

* 程式碼

```python
class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:

        def check(c: str) -> int:
            l = 0
            cnt = 0
            windowSize = 0
            ans = 0

            for r, a in enumerate(answerKey):
                windowSize += 1
                if a != c:
                    cnt += 1

                while cnt > k:
                    if answerKey[l] != c:
                        cnt -= 1
                    windowSize -= 1
                    l += 1
                
                ans = max(ans, windowSize)
            
            return ans
        
        return max(check("T"), check("F"))
```

## 時間與空間複雜度

* **時間複雜度：O(n)**
  * 每個字符最多被訪問 2 次（右指針一次，左指針一次）
  * `check` 函數調用 2 次，每次 O(n)
  * 總體：O(2n) = O(n)
* **空間複雜度：O(1)**
  * 只使用了常數個變量（l, cnt, windowSize, ans）
  * 沒有額外的數據結構
