---
description: Array, Binary Search, Prefix Sum, Sliding Window
---

# 713. Subarray Product Less Than K - Medium

## 釐清需求與邊界條件

* **輸入:**
  * `nums`: 正整數陣列
  * `k`: 正整數目標值
* **輸出:**
  * 返回乘積小於 k 的連續子陣列數量
* **邊界條件:**
  * `1 <= nums.length <= 3 * 10^4`
  * `1 <= nums[i] <= 1000`
  * `0 <= k <= 10^6`

## 口述解法

**滑動窗口 (Sliding Window)**

這個解法使用雙指針技術來維護一個滑動窗口，確保窗口內的乘積始終小於 k。

*   **主要函數步驟：**

    1. 初始化變數：`check`（當前窗口乘積）、`l`（左指針）、`ans`（結果計數）
    2. 使用右指針 `r` 遍歷陣列：
       * 將當前元素加入窗口（更新乘積）
       * 當窗口乘積 ≥ k 時，收縮左邊界直到乘積 < k
       * 計算以當前右指針為結尾的有效子陣列數量：`r - l + 1`

    **關鍵洞察：** 當窗口 `[l, r]` 的乘積小於 k 時，以 `r` 為結尾的所有子陣列都是有效的：

    * `[r]`, `[r-1, r]`, `[r-2, r]`, ..., `[l, r]`
    * 總共有 `r - l + 1` 個

## 測試與優化

* 程式碼

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        check = 1
        l = 0
        ans = 0

        for r, n in enumerate(nums):
            check *= n

            while l <= r and check >= k:
                check /= nums[l]
                l += 1

            ans += r - l + 1
        return ans
```

## 時間與空間複雜度

* 時間複雜度：O(n)
  * 內層 while ，但每個元素最多被左指針訪問一次
  * 總體：每個元素最多被處理兩次（一次加入，一次移除）
* 空間複雜度：O(1)
