---
description: Array Sliding Window
---

# 1052.Grumpy Bookstore Owner - Medium

## 釐清需求與邊界條件

* **輸入:**
  * `customers: List[int]` - 每分鐘的顧客數量
  * `grumpy: List[int]` - 店主每分鐘的情緒狀態 (0=不生氣, 1=生氣)
  * `minutes: int` - 秘密技巧的持續時間
* **輸出:**
  * `int` - 在最佳策略下能滿足的最大顧客數
* **邊界條件:**
  * `1 ≤ customers.length == grumpy.length ≤ 20000`
  * `0 ≤ customers[i] ≤ 1000`
  * `grumpy[i]` 只能是 0 或 1
  * `1 ≤ minutes ≤ customers.length`

## 口述解法

* 這是一個滑動窗口問題。要找到一個長度為 `minutes` 的窗口，使得在這個窗口內能額外滿足最多的顧客。
* **主要函數 maxSatisfied：**
  1. 計算基礎滿足的顧客數（店主不生氣時的顧客）
  2. 使用滑動窗口找出最佳的 `minutes` 時間段
  3. 返回基礎滿足數 + 額外滿足數
* **步驟說明：**
  1. 初始化變數：`all`(基礎滿足數), `l`(左指針), `s`(當前窗口額外收益), `cnt`(最大額外收益)
  2. 遍歷每一分鐘：
     * 如果店主生氣，將顧客數加入當前窗口收益
     * 如果店主不生氣，將顧客數加入基礎滿足數
  3. 當窗口大小達到 `minutes` 時：
     * 更新最大額外收益
     * 移動左指針，維持窗口大小

## 測試與優化

* 程式碼

```python
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        all = 0
        l = 0
        s = 0
        cnt = 0
        for r, cus in enumerate(customers):
            if grumpy[r] == 1:
                s += cus
            if grumpy[r] == 0:
                all += cus
            
            if r - l + 1 >= minutes:
                cnt = max(cnt, s)

                if grumpy[l] == 1:
                    s -= customers[l]

                l += 1

        return all + cnt
```

## 時間與空間複雜度

* 時間複雜度：O(n)
  * 只需要遍歷一次陣列，每個元素都被訪問常數次
* 空間複雜度：O(1)
  * 只使用了固定數量的變數，不隨輸入大小變化
