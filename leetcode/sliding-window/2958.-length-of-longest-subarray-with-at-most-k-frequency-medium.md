---
description: Array, Hash Table, Sliding Window
---

# 2958. Length of Longest Subarray With at Most K Frequency - Medium

## 釐清需求與邊界條件

* #### 輸入:
  * `nums`: 一個整數陣列，長度為 n (1 ≤ n ≤ 10^5)
  * `k`: 一個正整數，表示每個元素在子陣列中最多能出現的次數 (1 ≤ k ≤ nums.length)
* #### 輸出:
  * 返回一個整數，表示滿足條件的最長子陣列長度
  * 條件：子陣列中任何元素的出現次數都不超過 k 次
* #### 邊界條件:
  * 如果 k = 1，相當於找最長無重複元素的子陣列
  * 如果 k ≥ 陣列長度，整個陣列都符合條件
  * 單一元素的陣列長度為 1
  * 空陣列情況（雖然題目保證 n ≥ 1）

## 口述解法

*   這是一個典型的滑動窗口（Sliding Window）問題，使用雙指針技術：

    1. **初始化階段**：
       * 使用 `Counter()` 記錄窗口內每個元素的頻率
       * `l` (left) 指針指向窗口左邊界，初始為 0
       * `r` (right) 指針透過 for 迴圈遍歷陣列，代表窗口右邊界
       * `ans` 記錄到目前為止找到的最長子陣列長度
    2. **窗口擴展**：
       * 將 `nums[r]` 加入窗口，更新其頻率計數
    3. **窗口收縮**：
       * 檢查當前元素頻率是否超過 k
       * 如果超過，使用 while 迴圈持續移動左指針，直到頻率降到 k 以內
       * 每次移動左指針時，減少對應元素的頻率計數
    4. **更新答案**：
       * 計算當前窗口大小 `r - l + 1`
       * 更新最大長度記錄

    #### 核心策略：

    * **維持窗口合法性**：確保窗口內任何元素頻率都 ≤ k
    * **貪心思想**：對於每個右邊界位置，找到最大可能的左邊界
    * **單調性**：左指針只會向右移動，不會回退

## 測試與優化

* 程式碼

```python
class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        cnt = Counter()
        ans = 0
        l = 0

        for r, n in enumerate(nums):
            cnt[n] += 1
            
            while cnt[n] > k:
                cnt[nums[l]] -= 1
                l += 1

            ans = max(ans, (r-l+1))
        return ans
```

## 時間與空間複雜度

* 時間複雜度：O(n)
  * `l` 指針在整個算法過程中最多移動 n 次
  * 每個元素最多被 `l` 和 `r` 指針各訪問一次
* 空間複雜度：O(n)
