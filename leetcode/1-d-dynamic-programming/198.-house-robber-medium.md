---
description: Math, Dynamic Programming, Memoization
---

# 198. House Robber

## 釐清需求與邊界條件

* **輸入**: 整數陣列 `nums`，代表每間房子的金額
* **輸出**: 不觸發警報(不能連續搶)的情況下能搶劫的最大金額
* **邊界條件**:
  * 空陣列：如果 `nums` 為空，應返回 0
  * 只有一個元素：如果只有一間房子，直接返回該房子的金額
  * 只有兩個元素：如果有兩間房子，返回兩者中的最大值

## 口述解法

*   使用了動態規劃的思想。

    #### 主要函數 `rob(nums)`：

    1. 設定兩個變數 `n0` 和 `n1` 分別代表：
       * `n0`：前前一個房子為止的最大搶劫金額
       * `n1`：到前一個房子為止的最大搶劫金額（不包含當前房子）
    2. 遍歷每間房子，對於每個位置 `i`：
       * 計算 `new = max(n1, n0 + nums[i])`，即取"不搶當前房子"和"搶當前房子"兩種選擇中的最大值
       * 更新 `n0 = n1`，將前一個狀態記錄到前前一個中
       * 更新 `n1 = new`，將新計算的最大值記為前一個狀態
    3. 最後返回 `n1`，這是所有房子中能搶到的最大金額

## 測試與優化

* 程式碼

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n0 = 0
        n1 = 0
        new = 0

        for i in range(len(nums)):
            new = max(n1, n0 + nums[i])
            n0 = n1
            n1 = new

        return n1
```

## 時間與空間複雜度

* **時間複雜度**: O(n)
  * 其中 n 是房子的數量。我們只需要遍歷一次整個陣列。
* **空間複雜度**: O(1)
  * 只使用了三個變數 `n0`、`n1` 和 `new`，不隨輸入大小變化。
