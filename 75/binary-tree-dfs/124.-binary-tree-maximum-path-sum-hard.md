# 124. Binary Tree Maximum Path Sum - Hard

## 釐清需求與邊界條件

* **輸入**: 二叉樹的根節點
* **輸出**: 任何非空路徑的最大路徑和
* **邊界條件**:
  * 樹的節點數範圍是 \[1, 3 \* 10^4]
  * 節點值範圍是 \[-1000, 1000]
  * 路徑不一定要經過根節點
  * 路徑可以只包含一個節點
  * 節點可能有負值，這種情況下可能不選擇某些分支會得到更大的和

## 口述解法

*   #### 主要函數: maxPathSum

    * 創建一個全局變量 `ans` 初始化為負無窮（因為節點值可能是負數）
    * 調用輔助函數 `dfs` 來遍歷樹並計算最大路徑和
    * 返回 `ans` 作為結果


*   內部函數: dfs

    * **目的**: 計算以每個節點為根的子樹中的最大路徑和，同時更新全局最大路徑和
    * **邏輯**:
      1. 如果當前節點是 `None`，返回 0（基本情況）
      2. 遞歸計算左子樹的最大貢獻值，如果貢獻為負數，則取 0（即不選擇該路徑）
      3. 同理，計算右子樹的最大貢獻值
      4. 更新全局最大路徑和 `ans`，考慮以當前節點為拐點的路徑：當前節點值 + 左子樹貢獻 + 右子樹貢獻
      5. 返回當前節點能向上提供的最大貢獻：當前節點值 + max(左子樹貢獻, 右子樹貢獻)


* 關鍵思路：對於每個節點，我們考慮兩種情況：
  1. 該節點作為路徑的一部分向上提供貢獻
  2. 該節點作為路徑的拐點（左子樹->節點->右子樹）

## 測試與優化

* 程式碼

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        def dfs(root: Optional[TreeNode]) -> int:
            if root is None:
                return 0
            left = max(0, dfs(root.left))
            right = max(0, dfs(root.right))
            nonlocal ans
            ans = max(ans, root.val + left + right)
            return root.val + max(left, right)

        ans = -inf
        dfs(root)
        return ans
```

* 測資與注意事項
  * 至少需要訪問每個節點一次來確定最大路徑和，所以時間複雜度不可能低於 O(N)。

## 時間與空間複雜度

* **時間複雜度**: O(N)
  * 其中 N 是樹中的節點數。每個節點被訪問恰好一次。
* **空間複雜度**: O(H)
  * 其中 H 是樹的高度。
    * 在最壞情況下（樹退化為鏈表），空間複雜度為 O(N)
    * 在最好情況下（平衡二叉樹），空間複雜度為 O(log N)
